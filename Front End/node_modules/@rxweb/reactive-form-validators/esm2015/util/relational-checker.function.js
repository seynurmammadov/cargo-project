import { ApplicationUtil } from "./app-util";
import { FormProvider } from "./form-provider";
import { RegexValidator } from "./regex-validator";
import { AnnotationTypes } from "../core/validator.static";
import { ObjectMaker } from "./object-maker";
import { getConfigObject } from "../util/config-provider";
const operatorOpposite = {
    [AnnotationTypes.greaterThan]: AnnotationTypes.lessThan,
    [AnnotationTypes.lessThan]: AnnotationTypes.greaterThan,
    [AnnotationTypes.greaterThanEqualTo]: AnnotationTypes.lessThanEqualTo,
    [AnnotationTypes.lessThanEqualTo]: AnnotationTypes.greaterThanEqualTo,
};
export function relationalCheck(control, config, relationalOperatorName) {
    config = getConfigObject(config, control);
    const matchControl = config.fieldName ? ApplicationUtil.getFormControl(config.fieldName, control) : undefined;
    const matchControlValue = (matchControl) ? matchControl.value : config.value !== undefined ? config.value : '';
    if (FormProvider.ProcessRule(control, config)) {
        if (config.isArrayControl)
            return arrayControlValidation(control, config, relationalOperatorName);
        if (isValid(control, matchControlValue, relationalOperatorName) === false)
            return ObjectMaker.toJson(relationalOperatorName, config, [control.value, matchControlValue]);
    }
    return ObjectMaker.null();
}
function isValid(control, matchControlValue, relationalOperatorName) {
    if (RegexValidator.isNotBlank(control.value) && RegexValidator.isNotBlank(matchControlValue)) {
        let isValid = false;
        switch (relationalOperatorName) {
            case AnnotationTypes.greaterThan:
                isValid = parseFloat(control.value) > parseFloat(matchControlValue);
                break;
            case AnnotationTypes.lessThan:
                isValid = parseFloat(control.value) < parseFloat(matchControlValue);
                break;
            case AnnotationTypes.greaterThanEqualTo:
                isValid = parseFloat(control.value) >= parseFloat(matchControlValue);
                break;
            case AnnotationTypes.lessThanEqualTo:
                isValid = parseFloat(control.value) <= parseFloat(matchControlValue);
                break;
        }
        return isValid;
    }
    return null;
}
function setTimeFunc(invalidateControls) {
    let timeOut = setTimeout(() => {
        invalidateControls.forEach(t => {
            t.updateValueAndValidity();
        });
        clearTimeout(timeOut);
    }, 200);
}
function arrayControlValidation(control, config, relationalOperatorName) {
    let formArray = ApplicationUtil.getParentFormArray(control);
    let parentFormGroup = control.parent ? control.parent : undefined;
    let oppositeOperator = operatorOpposite[relationalOperatorName];
    let updateValidityControls = [];
    if (formArray && parentFormGroup && formArray.controls.length > 1) {
        let indexOf = formArray.controls.indexOf(parentFormGroup);
        let fieldName = ApplicationUtil.getFormControlName(control);
        let valid = true;
        if (indexOf > 0)
            valid = validateControl(formArray, control, indexOf - 1, fieldName, oppositeOperator, relationalOperatorName, updateValidityControls);
        if (valid && formArray.controls.length > indexOf + 1)
            valid = validateControl(formArray, control, indexOf + 1, fieldName, relationalOperatorName, relationalOperatorName, updateValidityControls);
        if (updateValidityControls.length > 0)
            setTimeFunc(updateValidityControls);
        if (valid === false)
            return ObjectMaker.toJson(relationalOperatorName, config, [control.value]);
    }
    return ObjectMaker.null();
}
function validateControl(formArray, control, indexOf, fieldName, oppositeOperator, relationalOperatorName, updateValidityControls) {
    let valid = false;
    let formGroup = formArray.controls[indexOf];
    if (formGroup && formGroup.controls) {
        let formControl = formGroup.controls[fieldName];
        valid = isValid(control, formControl.value, oppositeOperator);
        if (valid && formControl.errors && formControl.errors[relationalOperatorName])
            updateValidityControls.push(formControl);
    }
    return valid;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVsYXRpb25hbC1jaGVja2VyLmZ1bmN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJ4d2ViL3JlYWN0aXZlLWZvcm0tdmFsaWRhdG9ycy8iLCJzb3VyY2VzIjpbInV0aWwvcmVsYXRpb25hbC1jaGVja2VyLmZ1bmN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDN0MsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUNuRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDM0QsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzdDLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUMxRCxNQUFNLGdCQUFnQixHQUE4QjtJQUNoRCxDQUFDLGVBQWUsQ0FBQyxXQUFXLENBQUMsRUFBRSxlQUFlLENBQUMsUUFBUTtJQUN2RCxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsRUFBRSxlQUFlLENBQUMsV0FBVztJQUN2RCxDQUFDLGVBQWUsQ0FBQyxrQkFBa0IsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxlQUFlO0lBQ3JFLENBQUMsZUFBZSxDQUFDLGVBQWUsQ0FBQyxFQUFFLGVBQWUsQ0FBQyxrQkFBa0I7Q0FDeEUsQ0FBQTtBQUNELE1BQU0sVUFBVSxlQUFlLENBQUMsT0FBd0IsRUFBRSxNQUFXLEVBQUUsc0JBQThCO0lBQ2pHLE1BQU0sR0FBRyxlQUFlLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQzFDLE1BQU0sWUFBWSxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FB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QUcsU0FBUyxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM1QyxJQUFJLFNBQVMsSUFBSSxTQUFTLENBQUMsUUFBUSxFQUFFO1FBQ2pDLElBQUksV0FBVyxHQUFHLFNBQVMsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDaEQsS0FBSyxHQUFHLE9BQU8sQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLEtBQUssRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBQzlELElBQUksS0FBSyxJQUFJLFdBQVcsQ0FBQyxNQUFNLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQztZQUN6RSxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7S0FDaEQ7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNqQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQWJzdHJhY3RDb250cm9sIH0gZnJvbSBcIkBhbmd1bGFyL2Zvcm1zXCI7XHJcbmltcG9ydCB7IEFwcGxpY2F0aW9uVXRpbCB9IGZyb20gXCIuL2FwcC11dGlsXCI7XHJcbmltcG9ydCB7IEZvcm1Qcm92aWRlciB9IGZyb20gXCIuL2Zvcm0tcHJvdmlkZXJcIjtcclxuaW1wb3J0IHsgUmVnZXhWYWxpZGF0b3IgfSBmcm9tIFwiLi9yZWdleC12YWxpZGF0b3JcIjtcclxuaW1wb3J0IHsgQW5ub3RhdGlvblR5cGVzIH0gZnJvbSBcIi4uL2NvcmUvdmFsaWRhdG9yLnN0YXRpY1wiO1xyXG5pbXBvcnQgeyBPYmplY3RNYWtlciB9IGZyb20gXCIuL29iamVjdC1tYWtlclwiO1xyXG5pbXBvcnQgeyBnZXRDb25maWdPYmplY3QgfSBmcm9tIFwiLi4vdXRpbC9jb25maWctcHJvdmlkZXJcIjtcclxuY29uc3Qgb3BlcmF0b3JPcHBvc2l0ZTogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfSA9IHtcclxuICAgIFtBbm5vdGF0aW9uVHlwZXMuZ3JlYXRlclRoYW5dOiBBbm5vdGF0aW9uVHlwZXMubGVzc1RoYW4sXHJcbiAgICBbQW5ub3RhdGlvblR5cGVzLmxlc3NUaGFuXTogQW5ub3RhdGlvblR5cGVzLmdyZWF0ZXJUaGFuLFxyXG4gICAgW0Fubm90YXRpb25UeXBlcy5ncmVhdGVyVGhhbkVxdWFsVG9dOiBBbm5vdGF0aW9uVHlwZXMubGVzc1RoYW5FcXVhbFRvLFxyXG4gICAgW0Fubm90YXRpb25UeXBlcy5sZXNzVGhhbkVxdWFsVG9dOiBBbm5vdGF0aW9uVHlwZXMuZ3JlYXRlclRoYW5FcXVhbFRvLFxyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiByZWxhdGlvbmFsQ2hlY2soY29udHJvbDogQWJzdHJhY3RDb250cm9sLCBjb25maWc6IGFueSwgcmVsYXRpb25hbE9wZXJhdG9yTmFtZTogc3RyaW5nKSB7XHJcbiAgICBjb25maWcgPSBnZXRDb25maWdPYmplY3QoY29uZmlnLCBjb250cm9sKTtcclxuICAgIGNvbnN0IG1hdGNoQ29udHJvbCA9IGNvbmZpZy5maWVsZE5hbWUgPyBBcHBsaWNhdGlvblV0aWwuZ2V0Rm9ybUNvbnRyb2woY29uZmlnLmZpZWxkTmFtZSwgY29udHJvbCkgOiB1bmRlZmluZWQ7XHJcbiAgICBjb25zdCBtYXRjaENvbnRyb2xWYWx1ZSA9IChtYXRjaENvbnRyb2wpID8gbWF0Y2hDb250cm9sLnZhbHVlIDogY29uZmlnLnZhbHVlICE9PSB1bmRlZmluZWQgPyBjb25maWcudmFsdWUgOiAnJztcclxuICAgIGlmIChGb3JtUHJvdmlkZXIuUHJvY2Vzc1J1bGUoY29udHJvbCwgY29uZmlnKSkge1xyXG4gICAgICAgIGlmIChjb25maWcuaXNBcnJheUNvbnRyb2wpXHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheUNvbnRyb2xWYWxpZGF0aW9uKGNvbnRyb2wsIGNvbmZpZywgcmVsYXRpb25hbE9wZXJhdG9yTmFtZSlcclxuICAgICAgICBpZiAoaXNWYWxpZChjb250cm9sLCBtYXRjaENvbnRyb2xWYWx1ZSwgcmVsYXRpb25hbE9wZXJhdG9yTmFtZSkgPT09IGZhbHNlKVxyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0TWFrZXIudG9Kc29uKHJlbGF0aW9uYWxPcGVyYXRvck5hbWUsIGNvbmZpZywgW2NvbnRyb2wudmFsdWUsIG1hdGNoQ29udHJvbFZhbHVlXSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0TWFrZXIubnVsbCgpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBpc1ZhbGlkKGNvbnRyb2wsIG1hdGNoQ29udHJvbFZhbHVlLCByZWxhdGlvbmFsT3BlcmF0b3JOYW1lKSB7XHJcbiAgICBpZiAoUmVnZXhWYWxpZGF0b3IuaXNOb3RCbGFuayhjb250cm9sLnZhbHVlKSAmJiBSZWdleFZhbGlkYXRvci5pc05vdEJsYW5rKG1hdGNoQ29udHJvbFZhbHVlKSkge1xyXG4gICAgICAgIGxldCBpc1ZhbGlkID0gZmFsc2U7XHJcbiAgICAgICAgc3dpdGNoIChyZWxhdGlvbmFsT3BlcmF0b3JOYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGVzLmdyZWF0ZXJUaGFuOlxyXG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHBhcnNlRmxvYXQoY29udHJvbC52YWx1ZSkgPiBwYXJzZUZsb2F0KG1hdGNoQ29udHJvbFZhbHVlKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEFubm90YXRpb25UeXBlcy5sZXNzVGhhbjpcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBwYXJzZUZsb2F0KGNvbnRyb2wudmFsdWUpIDwgcGFyc2VGbG9hdChtYXRjaENvbnRyb2xWYWx1ZSlcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIEFubm90YXRpb25UeXBlcy5ncmVhdGVyVGhhbkVxdWFsVG86XHJcbiAgICAgICAgICAgICAgICBpc1ZhbGlkID0gcGFyc2VGbG9hdChjb250cm9sLnZhbHVlKSA+PSBwYXJzZUZsb2F0KG1hdGNoQ29udHJvbFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGNhc2UgQW5ub3RhdGlvblR5cGVzLmxlc3NUaGFuRXF1YWxUbzpcclxuICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBwYXJzZUZsb2F0KGNvbnRyb2wudmFsdWUpIDw9IHBhcnNlRmxvYXQobWF0Y2hDb250cm9sVmFsdWUpXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5mdW5jdGlvbiBzZXRUaW1lRnVuYyhpbnZhbGlkYXRlQ29udHJvbHM6IEFic3RyYWN0Q29udHJvbFtdKSB7XHJcbiAgICBsZXQgdGltZU91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGludmFsaWRhdGVDb250cm9scy5mb3JFYWNoKHQgPT4ge1xyXG4gICAgICAgICAgICB0LnVwZGF0ZVZhbHVlQW5kVmFsaWRpdHkoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lT3V0KTtcclxuICAgIH0sIDIwMClcclxufVxyXG5mdW5jdGlvbiBhcnJheUNvbnRyb2xWYWxpZGF0aW9uKGNvbnRyb2wsIGNvbmZpZywgcmVsYXRpb25hbE9wZXJhdG9yTmFtZSkge1xyXG4gICAgbGV0IGZvcm1BcnJheSA9IEFwcGxpY2F0aW9uVXRpbC5nZXRQYXJlbnRGb3JtQXJyYXkoY29udHJvbCk7XHJcbiAgICBsZXQgcGFyZW50Rm9ybUdyb3VwID0gY29udHJvbC5wYXJlbnQgPyBjb250cm9sLnBhcmVudCA6IHVuZGVmaW5lZDtcclxuICAgIGxldCBvcHBvc2l0ZU9wZXJhdG9yID0gb3BlcmF0b3JPcHBvc2l0ZVtyZWxhdGlvbmFsT3BlcmF0b3JOYW1lXTtcclxuICAgIGxldCB1cGRhdGVWYWxpZGl0eUNvbnRyb2xzID0gW107XHJcbiAgICBpZiAoZm9ybUFycmF5ICYmIHBhcmVudEZvcm1Hcm91cCAmJiBmb3JtQXJyYXkuY29udHJvbHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIGxldCBpbmRleE9mID0gZm9ybUFycmF5LmNvbnRyb2xzLmluZGV4T2YocGFyZW50Rm9ybUdyb3VwKTtcclxuICAgICAgICBsZXQgZmllbGROYW1lID0gQXBwbGljYXRpb25VdGlsLmdldEZvcm1Db250cm9sTmFtZShjb250cm9sKTtcclxuICAgICAgICBsZXQgdmFsaWQgPSB0cnVlO1xyXG4gICAgICAgIGlmIChpbmRleE9mID4gMClcclxuICAgICAgICAgICAgdmFsaWQgPSB2YWxpZGF0ZUNvbnRyb2woZm9ybUFycmF5LCBjb250cm9sLCBpbmRleE9mIC0gMSwgZmllbGROYW1lLCBvcHBvc2l0ZU9wZXJhdG9yLCByZWxhdGlvbmFsT3BlcmF0b3JOYW1lLCB1cGRhdGVWYWxpZGl0eUNvbnRyb2xzKVxyXG5cclxuICAgICAgICBpZiAodmFsaWQgJiYgZm9ybUFycmF5LmNvbnRyb2xzLmxlbmd0aCA+IGluZGV4T2YgKyAxKSBcclxuICAgICAgICAgICAgdmFsaWQgPSB2YWxpZGF0ZUNvbnRyb2woZm9ybUFycmF5LCBjb250cm9sLCBpbmRleE9mICsgMSwgZmllbGROYW1lLCByZWxhdGlvbmFsT3BlcmF0b3JOYW1lLCByZWxhdGlvbmFsT3BlcmF0b3JOYW1lLCB1cGRhdGVWYWxpZGl0eUNvbnRyb2xzKTtcclxuXHJcbiAgICAgICAgaWYgKHVwZGF0ZVZhbGlkaXR5Q29udHJvbHMubGVuZ3RoID4gMClcclxuICAgICAgICAgICAgc2V0VGltZUZ1bmModXBkYXRlVmFsaWRpdHlDb250cm9scyk7XHJcbiAgICAgICAgaWYgKHZhbGlkID09PSBmYWxzZSlcclxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdE1ha2VyLnRvSnNvbihyZWxhdGlvbmFsT3BlcmF0b3JOYW1lLCBjb25maWcsIFtjb250cm9sLnZhbHVlXSlcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3RNYWtlci5udWxsKCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHZhbGlkYXRlQ29udHJvbChmb3JtQXJyYXksIGNvbnRyb2wsIGluZGV4T2YsIGZpZWxkTmFtZSwgb3Bwb3NpdGVPcGVyYXRvciwgcmVsYXRpb25hbE9wZXJhdG9yTmFtZSwgdXBkYXRlVmFsaWRpdHlDb250cm9scykge1xyXG4gICAgbGV0IHZhbGlkID0gZmFsc2U7XHJcbiAgICBsZXQgZm9ybUdyb3VwID0gZm9ybUFycmF5LmNvbnRyb2xzW2luZGV4T2ZdO1xyXG4gICAgaWYgKGZvcm1Hcm91cCAmJiBmb3JtR3JvdXAuY29udHJvbHMpIHtcclxuICAgICAgICBsZXQgZm9ybUNvbnRyb2wgPSBmb3JtR3JvdXAuY29udHJvbHNbZmllbGROYW1lXTtcclxuICAgICAgICB2YWxpZCA9IGlzVmFsaWQoY29udHJvbCwgZm9ybUNvbnRyb2wudmFsdWUsIG9wcG9zaXRlT3BlcmF0b3IpO1xyXG4gICAgICAgIGlmICh2YWxpZCAmJiBmb3JtQ29udHJvbC5lcnJvcnMgJiYgZm9ybUNvbnRyb2wuZXJyb3JzW3JlbGF0aW9uYWxPcGVyYXRvck5hbWVdKVxyXG4gICAgICAgICAgICB1cGRhdGVWYWxpZGl0eUNvbnRyb2xzLnB1c2goZm9ybUNvbnRyb2wpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbGlkO1xyXG59Il19