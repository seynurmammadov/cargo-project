import * as tslib_1 from "tslib";
import { Input } from "@angular/core";
import { INPUT, SELECT, CHECKBOX, TEXTAREA, RADIO, FILE, CHANGE } from "../../const";
import { ControlExpressionProcess } from './control-expression-process';
var BaseValidator = /** @class */ (function (_super) {
    tslib_1.__extends(BaseValidator, _super);
    function BaseValidator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.validators = [];
        return _this;
    }
    BaseValidator.prototype.validation = function (control) {
        var e_1, _a;
        var result = null;
        try {
            for (var _b = tslib_1.__values(this.validators), _c = _b.next(); !_c.done; _c = _b.next()) {
                var validator = _c.value;
                result = validator(control);
                if (result)
                    break;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (!result && this.maskProvider)
            result = this.maskProvider.validate();
        return result;
    };
    BaseValidator.prototype.setEventName = function () {
        var eventName = '';
        switch (this.element.tagName) {
            case INPUT:
            case TEXTAREA:
                eventName = (this.element.type == CHECKBOX || this.element.type == RADIO || this.element.type == FILE) ? CHANGE : INPUT;
                break;
            case SELECT:
                eventName = CHANGE;
                break;
        }
        this.eventName = eventName.toLowerCase();
    };
    tslib_1.__decorate([
        Input(),
        tslib_1.__metadata("design:type", Object)
    ], BaseValidator.prototype, "formControl", void 0);
    return BaseValidator;
}(ControlExpressionProcess));
export { BaseValidator };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS12YWxpZGF0b3IuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQHJ4d2ViL3JlYWN0aXZlLWZvcm0tdmFsaWRhdG9ycy8iLCJzb3VyY2VzIjpbImRpcmVjdGl2ZXMvdGVtcGxhdGUtdmFsaWRhdGlvbnMvYmFzZS12YWxpZGF0b3IuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUUsS0FBSyxFQUFFLE1BQU0sZUFBZSxDQUFBO0FBRXJDLE9BQU8sRUFDSCxLQUFLLEVBQUUsTUFBTSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQ2pDLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUN0QixNQUFNLGFBQWEsQ0FBQztBQUVyQixPQUFPLEVBQUUsd0JBQXdCLEVBQUUsTUFBTSw4QkFBOEIsQ0FBQTtBQUd2RTtJQUFtQyx5Q0FBd0I7SUFBM0Q7UUFBQSxxRUFxQ0M7UUFsQ2EsZ0JBQVUsR0FBbUIsRUFBRSxDQUFDOztJQWtDOUMsQ0FBQztJQTdCRyxrQ0FBVSxHQUFWLFVBQVcsT0FBd0I7O1FBQy9CLElBQUksTUFBTSxHQUFHLElBQUksQ0FBQzs7WUFDbEIsS0FBc0IsSUFBQSxLQUFBLGlCQUFBLElBQUksQ0FBQyxVQUFVLENBQUEsZ0JBQUEsNEJBQUU7Z0JBQWxDLElBQUksU0FBUyxXQUFBO2dCQUNkLE1BQU0sR0FBRyxTQUFTLENBQUMsT0FBTyxDQUFDLENBQUM7Z0JBQzVCLElBQUksTUFBTTtvQkFDTixNQUFNO2FBQ2I7Ozs7Ozs7OztRQUNELElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLFlBQVk7WUFDN0IsTUFBTSxHQUFHLElBQUksQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDekMsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQztJQUdTLG9DQUFZLEdBQXRCO1FBQ0ksSUFBSSxTQUFTLEdBQVcsRUFBRSxDQUFDO1FBQzNCLFFBQVEsSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUU7WUFDMUIsS0FBSyxLQUFLLENBQUM7WUFDWCxLQUFLLFFBQVE7Z0JBQ1QsU0FBUyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLElBQUksUUFBUSxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxJQUFJLEtBQUssSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7Z0JBQ3hILE1BQU07WUFDVixLQUFLLE1BQU07Z0JBQ1AsU0FBUyxHQUFHLE1BQU0sQ0FBQztnQkFDbkIsTUFBTTtTQUNiO1FBQ0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDN0MsQ0FBQztJQWhDUTtRQUFSLEtBQUssRUFBRTs7c0RBQTRDO0lBb0N4RCxvQkFBQztDQUFBLEFBckNELENBQW1DLHdCQUF3QixHQXFDMUQ7U0FyQ1ksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElucHV0IH0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIlxyXG5pbXBvcnQgeyAgVmFsaWRhdG9yRm4sIEFic3RyYWN0Q29udHJvbCwgRm9ybUNvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XHJcbmltcG9ydCB7XHJcbiAgICBJTlBVVCwgU0VMRUNULCBDSEVDS0JPWCwgVEVYVEFSRUEsIFxyXG4gICAgUkFESU8sIEZJTEUsIENIQU5HRVxyXG59IGZyb20gXCIuLi8uLi9jb25zdFwiO1xyXG5cclxuaW1wb3J0IHsgQ29udHJvbEV4cHJlc3Npb25Qcm9jZXNzIH0gZnJvbSAnLi9jb250cm9sLWV4cHJlc3Npb24tcHJvY2VzcydcclxuaW1wb3J0IHsgTWFza1Byb3ZpZGVyIH0gZnJvbSAnLi4vLi4vZG9tYWluL2VsZW1lbnQtcHJvY2Vzc29yL21hc2sucHJvdmlkZXInO1xyXG5cclxuZXhwb3J0IGNsYXNzIEJhc2VWYWxpZGF0b3IgZXh0ZW5kcyBDb250cm9sRXhwcmVzc2lvblByb2Nlc3Mge1xyXG4gICAgQElucHV0KCkgZm9ybUNvbnRyb2w6IEZvcm1Db250cm9sIHwgQWJzdHJhY3RDb250cm9sO1xyXG5cclxuICAgIHByb3RlY3RlZCB2YWxpZGF0b3JzOiBWYWxpZGF0b3JGbltdICA9IFtdO1xyXG4gICAgcHJvdGVjdGVkIGVsZW1lbnQ6IGFueTtcclxuICAgIHByb3RlY3RlZCBldmVudE5hbWU6IHN0cmluZztcclxuICAgIHByb3RlY3RlZCBtYXNrUHJvdmlkZXI6IE1hc2tQcm92aWRlcjtcclxuXHJcbiAgICB2YWxpZGF0aW9uKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IHsgW2tleTogc3RyaW5nXTogYW55IH0ge1xyXG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xyXG4gICAgICAgIGZvciAobGV0IHZhbGlkYXRvciBvZiB0aGlzLnZhbGlkYXRvcnMpIHtcclxuICAgICAgICAgICAgcmVzdWx0ID0gdmFsaWRhdG9yKGNvbnRyb2wpO1xyXG4gICAgICAgICAgICBpZiAocmVzdWx0KVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghcmVzdWx0ICYmIHRoaXMubWFza1Byb3ZpZGVyKVxyXG4gICAgICAgICAgIHJlc3VsdCA9IHRoaXMubWFza1Byb3ZpZGVyLnZhbGlkYXRlKCk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcblxyXG4gICAgcHJvdGVjdGVkIHNldEV2ZW50TmFtZSgpIHtcclxuICAgICAgICB2YXIgZXZlbnROYW1lOiBzdHJpbmcgPSAnJztcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZWxlbWVudC50YWdOYW1lKSB7XHJcbiAgICAgICAgICAgIGNhc2UgSU5QVVQ6XHJcbiAgICAgICAgICAgIGNhc2UgVEVYVEFSRUE6XHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgPSAodGhpcy5lbGVtZW50LnR5cGUgPT0gQ0hFQ0tCT1ggfHwgdGhpcy5lbGVtZW50LnR5cGUgPT0gUkFESU8gfHwgdGhpcy5lbGVtZW50LnR5cGUgPT0gRklMRSkgPyBDSEFOR0UgOiBJTlBVVDtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIFNFTEVDVDpcclxuICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IENIQU5HRTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgfVxyXG5cclxuXHJcblxyXG59XHJcbiJdfQ==